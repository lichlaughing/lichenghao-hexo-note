---
title: JVM-类加载指北
categories: jvm
tags:
  - java
  - jvm
keywords: 'java,jvm'
cover: https://blog.lichenghao.cn/upload/2022/07/f7f1ff62-jvm.png
abbrlink: f7f1ff62
date: 2022-05-16 13:50:00
---
类加载是类生命周期中的一部分，类的生命周期可以分为以下几个阶段:

![](https://blog.lichenghao.cn/upload/2022/07/20143714-jvm.png)



Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的`类加载机制`。

## 什么时候开始类加载？

什么情况下开始类加载，《Java虚拟机规范》并没有明确指出，其规定了有以下几个情况则必须马上立即对类进行初始化（而加载、验证、准备自然需要在此之前开始）：

1. 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令的时候，如果没有进行过初始化，那么就要立刻触发初始化阶段。生成这四条指令的场景：
   1. 使用 new 关键字实例化对象的时候
   2. 读取或者设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）
   3. 调用一个类型的静态方法的时候
2. 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先进行初始化。
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 虚拟机启动后，用户需要指定一个需要执行的主类（包含 main()方法的类），虚拟机会先初始化这个主类。
5. 使用 JDK7 新加入的动态语言支持时，如果一个 java.lang.invoke.Methodhandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。
6. 当一个接口总定义了 JDK8 新加入的默认方法（default 关键字修饰）时，如果有这个接口的实现类发生了初始化，那么该接口要在其初始化之前被初始化。

上面这 6 个场景中的行为称为`对类进行主动引用`。除此之外的引用称为`被动引用`，被动引用不会触发初始化。

被动引用的示例

有如下父子类

```java
public class SuperClass {
    public static String HELLO = "hello world";
    public static int value = 100;

    static {
        System.out.println("superClass init ");
    }
}


public class SubClass extends SuperClass {
    static {
        System.out.println("subClass init");
    }
}
```



场景 1：子类调用父类的静态属性。

```java
public class App {
    public static void main(String[] args) {
        System.out.println(SubClass.HELLO);
    }
}
// 结果
superClass init 
hello world
```

对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。子类是否加载验证等取决于虚拟机的实现。HotSpot虚拟机来说，可以添加 -XX：+TraceClassLoading 参数来查看加载的日志会发现这个操作会导致子类加载。

```java
...
[Loaded cn.lichenghao.SuperClass from file:/Users/lichenghao/workspace/DevTest/Demo1/target/classes/]
[Loaded cn.lichenghao.SubClass from file:/Users/lichenghao/workspace/DevTest/Demo1/target/classes/]

[Loaded java.net.StandardSocketOptions$StdSocketOption from /Library/Java/JavaVirtualMachines/jdk1.8.0_271.jdk/Contents/Home/jre/lib/rt.jar]
[Loaded java.net.NetworkInterface from /Library/Java/JavaVirtualMachines/jdk1.8.0_271.jdk/Contents/Home/jre/lib/rt.jar]
superClass init 
100
...
```



场景 2：数组定义来引用类，不会触发类的初始化

```java
public class App {
    public static void main(String[] args) {
        SuperClass[] arr = new SuperClass[10];
    }
}
```



场景 3：引用类的常量，不会触发类的初始化

```java
public class App {
    public static void main(String[] args) {
        System.out.println(SubClass.HELLO);
    }
}
```

编译优化将常量放在了常量池中，所以实际上是引用了常量池中的数据。

## 加载(Loading)

加载是整个类加载过程中的第一个阶段，这个阶段 JVM 要查找并加载类的字节码文件，也就是我们的.class文件。

主要完成以下事情：

1. 通过一个类的全限定名称来获取定义此类的二进制字节流(该二进制字节流的来源有很多，例如：磁盘、数据库、内存、动态生成、zip)。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。

这个阶段是开发人员`插手`最多的阶段，加载阶段既可以使用 Java 虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。



{% note danger modern %}
数组不通过类加载器创建
{% endnote %}

数组比较特殊，它由虚拟机直接在内存中动态构建出来。但是数组中的元素最终还是需要加载器去完成加载。

## 连接(Linking)

XX

### 验证(Verification)

XX

### 准备(Preparation)

XX

### 解析(Resolution)

XX

## 初始化(Initialization)

XX



参考文档：

{% blockquote 周志明  https://www.aliyundrive.com/s/P6JQaCek3u5 %}
「深入理解Java虚拟机：JVM高级特性与最佳实践（第三版）」
{% endblockquote %}

