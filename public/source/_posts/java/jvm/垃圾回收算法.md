---
title: JVM-垃圾回收算法
categories: jvm
tags:
  - java
  - jvm
keywords: 'java,jvm,垃圾回收'
cover: https://blog.lichenghao.cn/upload/2022/07/e5213117-jvm.png
abbrlink: e5213117
date: 2022-05-15 13:53:00
---





## 标记-清除



![](https://blog.lichenghao.cn/upload/2022/07/09103212-jvm.png)



分成两个阶段，先把垃圾标记出来，再清除掉垃圾。

> 这里的清除不是把标记为垃圾的那块内存给清空掉，而是记录下内存的起始位置放在一个空闲地址列表里面，下次用的时候到这个空闲地址列表中查询，看是否有空间来存新对象。

**优点：**

- 速度很快，记录下垃圾对象的所占内存的起始位置即可

**缺点：**

- 执行效率不稳定，如果堆中有大量对象，其中大部分需要被回收，这个时候需要进行大量的标记和清除动作，所以执行效率会伴随着对象的增多而降低

- 缺点也很明显，标记清除后，产生了很多内存碎片，导致空间不连续，如果来了一个大的对象，虽然整体空间够用，但是每个碎片都放不下这个大对象也会造成内存溢出



## 标记-整理



![](https://blog.lichenghao.cn/upload/2022/07/09104538-jvm.png)



标记完垃圾后，将可用的内存的内存整理到一起，这样就避免了标记-清除中的内存碎片问题。

**优点：**

- 避免出现内存碎片

**缺点：**

- 整理就会移动对象，涉及到对象的局部变量，其他对象的引用的改变等，做的工作较多，所以速度较慢



## 标记-复制



![](https://blog.lichenghao.cn/upload/2022/07/09105558-jvm.png)



内存分成两块区域，FROM-TO 其中 TO 保持为空。标记垃圾后，将非垃圾复制到 TO 中并且做好了整理，然后将 FROM 整个清空，最后将原来的 TO 作为 FROM ,原来的 FROM 作为 TO。

**优点：**

- 不会出现内存碎片

**缺点：**

- 会占用双倍的内存空间



## 小结



| 算法名称                   | 优点         | 缺点               |
| -------------------------- | ------------ | ------------------ |
| Mark Sweep（标记-清除）    | 速度快       | 造成内存碎片       |
| Mark Compact （标记-整理） | 没有内存碎片 | 速度较慢           |
| Copy （标记-复制）         | 没有内存碎片 | 占用双倍的内存空间 |





## 分代垃圾回收机制

JVM在做垃圾回收的时候，不是就使用上面说的一种算法，而是配合使用上面的算法。JVM 在做垃圾回收的时候采用分代回收的机制，充分利用了上面算法的优势。

![](https://blog.lichenghao.cn/upload/2022/07/09112925-jvm.png)



简单过程：

1. 对象首先分配在伊甸园区
2. 新生代内存不足时，触发 minor gc，伊甸园和 FROM 存活的对象使用 copy 算法复制到 TO 中，存活的对象年龄+1，并且交换 FROM 和 TO 区，释放 FROM 内存
3. 发生 minor gc 的时候，会触发 stop the world ,暂停其他线程，等我垃圾回收完毕后，其他的线程再继续运行
4. 当对象的年龄超过阈值，就会晋升到老年代。（阈值最大为 15 ，存储在对象头中）
5. 当老年代的空间也不足的时候，先尝试做 minor gc，如果空间仍然不足，就会触发 full gc，这时候的 stop the world 的时间会更长
6. 如果 full gc 后，空间仍然不够，那么就会 OOM





