---
title: 机器数、真值、原码、反码、补码
categories: java
tags:
  - java
  - 补码
date: 2022-01-01 00:11:00
abbrlink: 267393a9
---
JAVA 基本数据类型中 byte 的取值范围是 -128 ~ 127 (-2^7~2^7-1),但是你了解过为什么 byte 的取值范围是这个吗？

要想知道这个范围是如何计算出来的，需要了解下计算机是如何进行减法的，很遗憾计算机不会做减法，因为减法会增加电路设计的复杂度，所以计算机会把减法当做加法来处理，也就是减去一个数等同于加上一个负数。那么负数在计算机中是如何表示的？以及他们是如何做加减法的？

那么下面所说的概念，反码，补码都是为了解决减法问题而引入的，不要小看减法，他可比加法恶心多了~

下面是一些概念



## 机器数



一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为 0, 负数为 1

比如：十进制中的数 +3，占用一个字节，转换成二进制就是 0000 0011。如果是 -3 ，就是 1000 0011 。这里的 00000011 和 10000011 就是机器数



## 真值



将带符号位的机器数对应的真正数值称为机器数的真值

因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位 1 代表负，其真正数值是 -3 而不是形式值 131（10000011 转换成十进制等于 131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例： 0000 0001[机器数] 的真值 = +000 0001 = +1 ; 1000 0001[机器数] 的真值 = –000 0001 = –1



## 原码



同机器数一样，用第一位表示符号(0 正 1 负), 其余位表示值

比如：

+1 原码 = 0111 1111 ； -1 原码 = 1000 0001
因为第一位是符号位，那么二进制数的取值范围：[1111 1111 , 0111 1111] 转换成十进制即 [-127 , 127] ，是不是感觉不对，继续往下看

好了，现在我们知道数值在计算机中的表示方法了，那么我们列举几个数字(4 位二进制)，然后做加减看看结果。

| 正数 | 原码 | 负数 | 原码 |
| ---- | ---- | ---- | ---- |
| +0   | 0000 | -0   | 1000 |
| 1    | 0001 | -1   | 1001 |
| 2    | 0010 | -2   | 1010 |
| 3    | 0011 | -3   | 1011 |
| 4    | 0100 | -4   | 1100 |
| 5    | 0101 | -5   | 1101 |
| 6    | 0110 | -6   | 1110 |
| 7    | 0111 | -7   | 1111 |

接下来我们计算：

1 + 1 = 0001 + 0001 = 0010 对应原码结果： 2 结果：正确 ✅

1+ 2 = 0001 + 0010 = 0011 对应原码结果 3 结果：正确 ✅

0+(-0) = 0000 + 1000 = 1000 对应原码结果： -0 ：也算对吧

1 + (-1) = 0001 + 1001 = 1010 对应原码结果 -2 ：错误 ❌

2 + (-2) = 0010 + 1010 = 1100 对应原码结果 -4 ：错误 ❌

可以看出来，使用原码的情况下，正数进行计算的时候是没有问题，但是如果有负数的话，计算是错误的，一个正数加上它对应的负数不等于 0；而且计算结果还有个-0 也很奇怪，为了解决这个问题，那么`反码`来了。



## 反码



正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各位取反

例如：

| 正数 | 原码 | 反码 | 负数 | 原码 | 反码 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0000 | 0111 | -0   | 1000 | 1111 |
| 1    | 0001 | 0001 | -1   | 1001 | 1110 |
| 2    | 0010 | 0010 | -2   | 1010 | 1101 |
| 3    | 0011 | 0011 | -3   | 1011 | 1100 |
| 4    | 0100 | 0100 | -4   | 1100 | 1011 |
| 5    | 0101 | 0101 | -5   | 1101 | 1010 |
| 6    | 0110 | 0110 | -6   | 1110 | 1001 |
| 7    | 0111 | 0111 | -7   | 1111 | 1000 |

这个时候我们用反码继续来计算下：

1 + 1 = 0001 + 0001 = 0010 转换成十进制 2 结果：正确 ✅

1+ 2 = 0001 + 0010 = 0011 转换成十进制 3 结果：正确 ✅

0+(-0) = 0000 + 1111 = 1111 对应的反码结果：-0 也还行

1 + (-1) = 0001 + 1110 = 1111 对应反码结果：-0，也还行

2 + (-2) = 0010 + 1101 = 1111 对应反码结果：-0，也还行

1+(-2) = 0001 + 1010 = 1011 对应反码结果：-4，错误 ❌

利用反码的情况下，正数和他对应的负数相加结果还行，但是一个正数和另外一个负数相加结果就是不对的了。

那我们试一试负数+负数, 结果肯定是负数。

(-1) + (-2) 可以看成是 1 + 2 然后加个符号位 也就是 0001 + 0010 = 0011 加上符号位 1011 结果是 -4 结果肯定也是不对。

怎么办？科学家们肯定是办法了，那么最终的补码来了~



## 补码



补码的计算方法，只是计算方法，不是补码的定义：

- 正数的补码就是其本身，负数的补码为反码+1。
- 负数的补码等于他的原码自低位向高位，尾数的第一个‘1’及其右边的‘0’保持不变，左边的各位按位取反，符号位不变

要想知道补码到底是咋定义的，可以去查计算机组成原理

那么来看下几个数的补码，正数的原码，反码，补码都是本身，就不说了，主要来看下负数

| 负数 | 原码 | 反码 | 补码     |
| ---- | ---- | ---- | -------- |
| -0   | 1000 | 1111 | ~~0000~~ |
| -1   | 1001 | 1110 | 1111     |
| -2   | 1010 | 1101 | 1110     |
| -3   | 1011 | 1100 | 1101     |
| -4   | 1100 | 1011 | 1100     |
| -5   | 1101 | 1010 | 1011     |
| -6   | 1110 | 1010 | 1011     |
| -7   | 1111 | 1000 | 1001     |
| -8   |      |      | 1000     |

在补码上，-0 不存在，取代的是-8

接下来我们用补码来计算：

1 + (-2) = 0001 + 1110 = 1111 对应补码结果：-4，正确 ✅

2 + (-4) = 0010 + 1100 = 1110 对应补码的结果：-2 ，正确 ✅

上面的例子中，使用了 4 位二进制数，它的最大值为 0111 ，最小值为 1000 ，所以它的有符号位的取值范围为：-8 ~ 7

了解了上面的概念之后，就可以来解析下基本数据类型 byte 的取值范围的问题了

JAVA 基本数据类型中 byte 占用一个字节 8 位，如果带符号的话最大值为：0111 1111 ， 最小值为：1000 0000，所以取值范围是：

-128 ~ 127 啦

参考文档：

https://blog.csdn.net/qq_23418393/article/details/57421688

https://www.imooc.com/article/16813?block_id=tuijian_wz

## 附：补码是咋定义的？

从上面的例子也能看出为了解决符号位参与运行才引入的补码。补码是一种基于**取模同余**的模运算系统的编码方法。

最好的例子就是时钟

有 12 个数字，同时 12 也可以表示为 0

假如现在是 6 点，那么把 6 点拨到 4 点有两种方式，一种是直接逆时针拨 2 格，另外一种是顺时针拨 10 格。

可以理解为从 6 拨到 4 转换成计算 6-2 和 6+10 的效果是一样的，也就是说 6-2=4 和 6+10=16 的效果是一样的。

也就说把 -2 的减法运算转换成了+10 的加法运算，并且最终的效果是一样的。这种方式叫做**取模同余**, 体现在 16 对 12 取模的结果就是 4

比如其他的例子：

-1 = + 11 mod 12

-2 = + 10 mod 12

-3 = + 9 mod 12

可以得出结论，负数的绝对值和右边的整数和为 12，这是一个模 12 运算系统，其中称-1 的补码为 11，也就是模减去负数的绝对值

那么比如说 2-2 就可以转换成 2 加上-2 的补码即可。

上面的我们用 4 位二进制的例子中，可以表示的数为 2 ^ 4 = 16 个，把他看成 16 位模运算系统。

计算 2 - 2：2 + ( -2 ) = 2 + ( 2 ^ 4 - 2) = 2 + 16 = 0010 + 1110 = 1000 = 0000 ，因为是 4 位运算器，最高一位会被舍去，保留下来的就是 0000 即 0



最终结论：如果有 N 位运算器：

-m 的补码为：2 ^ n - m

补码表示的取值范围：[ -2 ^ (n-1) , 2 ^ (n-1) -1 ]



参考文章：https://www.cnblogs.com/banmei-brandy/p/12299655.html
