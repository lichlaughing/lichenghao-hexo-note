---
title: 正则表达式
categories: java
tags:
  -	正则表达式
abbrlink: 2f57a694
---



通过正则表达式能匹配我们需要的字符串或者验证给定的字符串是否符合我们的预期要求。

例如我们在搜索 markdown 文档的时候，我们在电脑上可以通过`.md `搜索我们的 md 文件，对应的正则可能是`^\w*\.md$`

那么更复杂的正则表达式可能是这样：匹配 Email：**^\w+([-+.]\w+)\*@\w+([-.]\w+)\*\.\w+([-.]\w+)\*$**

# 元字符

要写成这样的正则表达式，首先的知道基本的元字符如下所示：

| 语法 | 说明                         |
| :--- | ---------------------------- |
| .    | 匹配除换行符以外的任意字符   |
| \w   | 匹配字母或数字或下划线或汉字 |
| \s   | 匹配任意的空白符             |
| \d   | 匹配数字                     |
| \b   | 匹配单词的开始或结束         |
| ^    | 匹配字符串的开始             |
| $    | 匹配字符串的结束             |

# 限定符

通常字符串会重复的出现，那么表示重复次数的限定字符如下所示：

| 语法  | 说明              |
| ----- | ----------------- |
| \*    | 重复零次或更多次  |
| +     | 重复一次或更多次  |
| ?     | 重复零次或一次    |
| {n}   | 重复 n 次         |
| {n,}  | 重复 n 次或更多次 |
| {n,m} | 重复 n 到 m 次    |

例如：\d{5,12} 表示 5~12 个数字

# 代替元字符

\w 匹配字母或数字或下划线或汉字，如果我们只想匹配字母中的几个字母可以使用[],例如[a,b,c], 或者[0-9]表示的意思和\d 是一样的。其中-表示范围的意思。

# 转义字符

比如我们想要匹配*，因为 * 表示重复，所以需要匹配它需要先转义 \\\*

# 元字符反义

通过元字符 \w 匹配字母数字下划线文字，那么将 w 改成大写\W 表示匹配任意不是字符，数字，下划线，文字的字符。其他的反义字符如下所示：

| 语法     | 说明                                       |
| -------- | ------------------------------------------ |
| \W       | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S       | 匹配任意不是空白符的字符                   |
| \D       | 匹配任意非数字的字符                       |
| \B       | 匹配不是单词开头或结束的位置               |
| [^x]     | 匹配除了 x 以外的任意字符                  |
| [^aeiou] | 匹配除了 aeiou 这几个字母以外的任意字符    |

# 分支条件

使用 | 表示多个分支条件，比如 ：^(aa|bb)+.\*\.md$ 可以匹配 aa1234.md 或者 bb 哈哈.md 。表示以 aa 或者 bb 开头的文件

# 子表达式（分组）

上面写的这个 ^(aa|bb)+.\*\.md$ 开头用小括号包裹起来的就是一个分组，如果有多个小括号的话，从左到右编号从 1 开始。

比如一个 IP 地址的正则有很多的分组：

```properties
(?:25[0-5]|2[0-4]\d|[0-1]?\d{1,2})(?:\.(?:25[0-5]|2[0-4]\d|[0-1]?\d{1,2})){3}$
```

# 分组后向引用

使用小括号指定了分组，如果这个分组的字符串，在匹配的后面还需要继续使用，就可以使用该分组的编号来做后续的操作。

默认情况下，每个分组都会有一个编号，从左到右，编号从 1 开始。

\b(\w+)\b\s+\1\b 可以用来匹配类似这样的 go go , hello hello 短语，这里\1 表示匹配分组 1 中 \b(\w+)\b ：至少一个单词的字符

所以这个正则的表示：匹配一个词的开始和结束至少包含一个字母数字下划线汉子，然后是至少一个空白符，最后是分组 1 中匹配的内容

# 断言

## 零宽断言

两个表达式：

（?=exp）：表示后面的内容和匹配 exp 的内容但是结果不包含 exp 的内容。

(?<=exp) ：表示前面的内容匹配 exp 的内容但是结果不包含 exp 的内容。

直接看例子：

1. \b\w+(?=ing\b) 匹配以 ing 结尾的单词的前面的部分，并不包括 ing。如查找*I'm singing while you're dancing.*时，它会匹配 sing 和 danc。
2. (?<=\bre)\w+\b 匹配以 re 开头的单词，并不包括 re。如 reading a book ，会匹配 ading

所以匹配的过程中 exp 会占据一个位置来匹配，但是匹配结果又不会包括这个位置的字符，所以叫`零宽断言`。

## 负向零宽断言

两个表达式：同零宽断言整好相反

（?!exp）：表示后面的内容和不匹配 exp 的内容并且结果不包含 exp 的内容。

(?<=exp)：表示前面的内容不匹配 exp 的内容并且结果不包含 exp 的内容。

直接看例子：

1. \b\w*q(?!u)\w*\b 匹配字母 q 后面不是 u 的一个单词，比如：acqu、abqq、abq， 得到结果 abqq,abq
2. (?<![a-z])\d{7} 匹配前面不是小写字母的 7 位数字，比如 w1234567、W1234567，得到结果 1234567

匹配的过程中用于表示 False 的意思，同样 exp 会占据一个位置，但是匹配的结果又不会包括这个位置的字符，所以叫`负向零宽断言`


注：对于第一个例子，我们可以使用反义来解决，比如`\b\w*q[^u]\w*\b`，但是会有一个问题，因为`[^u]`是必须要匹配一个位置的，所以如果当 q 是单词的末尾的话如 req，那么这个正则就会出错。如果使用(?!exp)就没有问题。

# 贪婪(最长)和懒惰(最短)

通常情况下，正则表达式在能匹配上的前提下，会尽可能多的匹配字符，比如 a.\*b 会匹配 a 开头 b 结尾的很长的字符，像 acccacccb, 这种情况被称之为贪婪（最长）。

但是有些情况下我们需要匹配更少的字符即可，只需要在限定符上加上？就可以变成懒惰（最短）匹配模式，表示尽可能匹配较少的字符。比如 a.\*?b 匹配 a 开头 b 结尾最短的单词，像 aabab 就会匹配出 aab , ab 。是不是好奇第一个难道不应该是 ab,为啥是 aab？



这里是由于匹配的一个优先规则：**最先开始的匹配拥有最高的优先权**

意思是说：当我们匹配了第一个字母 a 之后，如果后面的匹配没有发生错误，那么会一直匹配下去,直到匹配到结尾 b,所以匹配的结果是 aab. 例如匹配 aabaaab 的结果就是 aab , aaab



---



推荐：https://regex101.com/

其他：https://tool.oschina.net/regex，http://www.regexp.cn/Regex





请参考这篇优秀的文章，正则表达式 30 分钟入门. https://deerchao.cn/tutorials/regex/regex.htm

