---
title: 计算机网络-传输层TCP/UDP
categories: network
tags:
  - network
  - TCP
  - UDP
keywords: 'network,计算机网络'
abbrlink: f4825627
date: 2022-02-20 12:00:00
---


参考文章：

?>[ 一篇文章带你熟悉 TCP/IP 协议（网络协议篇二)]( https://juejin.cn/post/6844903510509633550)

?>  [CS-Notes - 计算机网络 ](http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.html#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5)

## 传输层TCP/IP

字面意思是传输层的TCP协议和网络层的IP协议，实际上也有这种情况，在大多数情况下，TCP/IP指的是利用IP进行通信时相关的一组协议的统称，例如IP、ICMP、TCP、UDP、FTP、HTTP等。他们是互联网必不可少的组成部分，因此可以称TCP/IP为网际协议群。

那么在TCP/IP四层模型中，我们来看下数据的处理流程~



![](https://blog.lichenghao.cn/upload/2022/07/152145.png)

## TCP/UDP

物理层通过MAC地址确定通信的两台设备，网络层通过IP确定两台传递数据的设备，传输层网络协议通过端口号确定两个设备上的哪两个应用程序进行通信。传输层有两个代表的协议：TCP ,UDP

**UDP（User Datagram Protocol）**

用户数据报文协议，是无连接的，尽最大可能交付，面向报文，支持一对一，一对多，多对一，多对多的交互通信

（面向报文：对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部）。

**TCP（Transmission Control Protocol）**

 传输控制协议，面向连接，提供可靠交付，有流量控制，拥塞控制，提供双全工通信，面向字节流，并且每一条 TCP 连接只能是点对点的（一对一）。

（面向字节流：把应用层传递过来的数据看成字节流，把字节流组织成大小不等的数据）。

TCP报文段首部如下所示：

![](https://blog.lichenghao.cn/upload/2022/07/131554.png)

- 序号

用于对字节流进行编号，例如序号为301，表示第一个字节的编号为301，如果携带的数据长度为200，那么下一个报文段的序号应该是501。

- 确认号

期望收到的下一个报文段的序号。例如B正确收到A发送来的一个报文段，序号为501，携带的数据长度为200，因此B期望下一个报文段的序号为701，B发送给A的确认报文中的确认号就是701。

- 数据偏移

数据部分距离报文段起始位置的偏移量，实际上指的就是首部的长度

- 紧急URG

当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据

- 确认ACK

当ACK=1时确认号字段有效，否则无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK设置为1

- 推送PSH

当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；

- 复位RST

当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；

- SYN	

在建立连接的时候用来同步序号。当SYN=1,ACK=0 时候表示这是一个建立连接请求报文段。若对方同意建立连接，则响应报文中SYN=1,ACK=1

- FIN

FIN=1,表示发送的报文段数据已经全部发送完毕，要求释放连接

- 窗口

占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；因为数据接收方的数据缓存空间是有限的

- 校验和

占2字节，校验首部和数据这两部分；

- 紧急指针

占2字节，指出本报文段中的紧急数据的字节数；

- 选项

长度可变，定义一些其他的可选的参数。

## TCP握手挥手

TCP是面向连接，提供可靠交付的协议，其在传输数据之前通过三次握手做好了传输的准备，TCP在建立连接的时候客户端和服务器总共发送三个包确定连接的建立，也就是所谓的"三次握手"。示意图如下所示：

![](https://blog.lichenghao.cn/upload/2022/07/155359.png)

通过图上的说明，可以很清楚的看出来三次握手的过程，里面的参数需要TCP头部参考去理解。用图还是很抽象的，我们通过`Wireshark`工具抓包来看下三次握手的过程。

## Wireshark抓包分析握手

使用`Wireshark`抓包，选择本地的网卡，浏览器访问`http://www.baidu.com`，选择http过滤，HTTP/1.1的那条记录右键选择`跟踪流-TCP流`，一次抓包的结果如下所示：可以看出`三次握手`之后，成功的建立了连接。

![](https://blog.lichenghao.cn/upload/2022/07/161415.png)



第一次握手，标志位为SYN,Seq=0 

![](https://blog.lichenghao.cn/upload/2022/07/163044.png)

第二次握手，标志位为SYN ACK=1 , ask = 1 Seq=0

![](https://blog.lichenghao.cn/upload/2022/07/163454.png)

第三次握手，标志位为ACK,Seq=1,ack=1,已经成功建立了连接

![](https://blog.lichenghao.cn/upload/2022/07/163936.png)

然后接下来就是http的post请求等等

?> 抓包示例数据：[tcp三次握手抓包.zip](https://wws.lanzoui.com/iHBmfnug6oj)  使用过滤条件：tcp && ip.addr==120.131.3.40



## TCP 协议为什么能提供可靠传输？

所有的知识点总结上，都会说传输控制协议，面向连接，提供可靠交付。TCP 为了保证传输的可靠性可是下足了功夫，手段极其多：

- 序号+确认应答机制
- 重传
- 流量控制
- 滑动窗口
- 拥塞控制

### 序号和确认应答机制

在 TCP 报文首部中有个序号字段，用来表示第一个字节的序号（每一个字节占一个序号），这样的话接收端就会知道下个报文的开始和结束位置，如下所示：

![](https://blog.lichenghao.cn/upload/2022/07/f963414c233111ec96810a80ff2603de.png)



### 重传机制

- 超时重传
- 快速重传

#### 超时重传

最先想到的可定是超时重传，网络不稳定等等因素导致。TCP 发送方在发送报文的时候，设定一个定时器，如果在规定的时间内没有收到接收方发来的 ACK 确认报文，发送方就会重传这个已发送的报文段。

那么没有接收到响应（丢包）也分两种情况：一种就是根本没发出去，一种就是发出去了没收到响应

![](https://blog.lichenghao.cn/upload/2022/07/f963423c233111ec96810a80ff2603de.png)

那么问题来了，超时多久后要进行重传的操作？这个超时时间要定多久呢？计算这个时间就需要计算下我的包发出去到给我响应需要多久的时间？

这里有个定义：RTT (Round-Trip Time) 往返时间，意思就是数据从发送出去到接收到响应的时间。超时重传的时间定义为 RTO(Retransmission Timeout)。

![](https://blog.lichenghao.cn/upload/2022/07/f96342b4233111ec96810a80ff2603de.png)

那么只要 RTO>RTT 那么这个超时重传的机制就是可用的，解决了丢包的问题，但是这里面也同时有很多的小问题，比如：

- RTO 远远大于 RTT 那么中间等待的时间将浪费很多的网络资源

- RTO 小于 RTT 我还没传送到呢，你就疯狂的给我重试，另外一段是不是的忙的要死
- ......

TCP是有一定的超时重传的时间策略的：重传的超时间隔加倍，每进行一次超时重传，都会将下一次重传的超时时间间隔设为先前值的两倍。但是这样也会存在RTO 的时间会很长的问题。所以科学家们有发明了新的重传方法，快速重传。

#### 快速重传

（Fast Retransmit）机制不以时间为驱动，而是以数据驱动重传。

原理：接收方接到比期望序号大的失序报文到达时候，就会向发送放发送一个冗余 ASK，表明下一个期待的序号

如下快速重传示意图：

![](https://blog.lichenghao.cn/upload/2022/07/f9634322233111ec96810a80ff2603de.png)

发送放发送 1-6 个报文，接收方：

- 收到报文段 1，期望下个报文序号是 2
- 收到报文段 3，冗余发送期望报文序号是 2
- 收到报文段 4，冗余发送期望报文序号是 2
- 收到报文段 5，冗余发送期望报文序号是 2
- - 这个时候发送端收到 3 个报文段 2 的冗余报文，那么说明报文段 2 丢失了，马上重传
- 收到报文段 2，返回确认报文，同时期望下个报文序号是 6（因为前面345报文段都收到了，但是不是说一个报文一个确认，确认后才会发送下一个报文吗？这样的话重试发送了报文 2，应该返回确认报文，并且希望下个报文序号应该是 3 猜对，这就涉及到累积应答）

?> TCP 有序号和确认应答机制，但是不是说发送方之后再接收了确认应答之后，在继续发送下一个报文段，这样明显效率很低。发送方往往会发送一批报文，而接收方也不是收到就立刻给出确认应答，而是延迟一小会，然后也是一批的报文确认给发送方，也就是累积确认或者叫累积应答。



### 滑动窗口

滑动窗口实际是操作系统的一个缓存区，发送方在等待确认应答报文返回之前，在缓存区中暂存发送的数据。如果在规定时间内收到了确认应答，就将缓存的数据删除。说白了，我通过窗口大小来控制你数据报文的发送速度。

**窗口多大合适？**

TCP 报文首部中有个窗口window字段，该字段能确认你这个窗口设置多大合适，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

#### 发送方的滑动窗口

![](https://blog.lichenghao.cn/upload/2022/07/f963437c233111ec96810a80ff2603de.png)

如果我们送了全部的数据，那么窗口如下所示：

![](https://blog.lichenghao.cn/upload/2022/07/f96343ea233111ec96810a80ff2603de.png)

如果接收到确认数据,那么窗口就要移动确认部分

![](https://blog.lichenghao.cn/upload/2022/07/6dc9fd8e235311ecb0460a80ff2603de.png)

那么程序如何知道窗口的这四个部分是多大的呢？TCP 使用了三个指针来计算这四个部分的大小。

![](https://blog.lichenghao.cn/upload/2022/07/32da35b6235511ec999e0a80ff2603de.png)

- SND.WND 

表示发送窗口的大小（大小是由接收方指定的）

- SND.UNA

是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号

- SND.NXT

也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号



#### 接收方的滑动窗口

接收方指针就相对简单多了

![](https://blog.lichenghao.cn/upload/2022/07/e1eabccc235711eca5a80a80ff2603de.png)

使用两个指针即可

- RCV.WDN

表示接收窗口的大小，它会通告给发送方

- RCV.NXT

是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号

指向未接收数据部分的第一个字节是个相对指针，它需要 `RCV.NXT` 指针加上 `RCV.WND` 大小的偏移量，就可以了。

### 流量控制

其实流量控制其实就是应用了滑动窗口协议。因为发送方不能不顾及接收方的感受而一顿发送数据。所以为了更好，更稳定的传输TCP提供一种机制让发送方可以根据接收方的实际处理能力来发送数据，这就是流量控制。





### 拥塞控制

拥塞控制主要是四个算法：

- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复

......





















