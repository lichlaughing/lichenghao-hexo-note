---
title: Mysql 锁
categories: mysql
tags:
  - mysql
  - Lock
keywords: 'msyql,数据库,全局锁,表级锁,行级锁'
abbrlink: b2644c62
date: 2022-02-02 09:40:00
---
锁是计算机协调多个进程或者线程并发访问某一个共享资源的机制。保证数据并发访问的一致性，有效性是数据库必须解决的一个问题，同时锁冲突也是影响数据库并发访问性能的一个重要因素。



锁分类：全局锁，表级锁，行级锁

## 全局锁

全局锁对整个数据库示例加锁，加锁后整个实例处于只读状态，后面的 DML,DDL 等都被阻塞。比如做数据库的备份，对所有的表进行锁定，保证数据的完整。

例如：

```sql
flush tables with read lock;

mysqldump --opt --user=root --password=123456 --ignore-table=table_a  --ignore-table=table_b --result-file=/data/bak.sql --default-character-set=utf8 -B dataBaseName;

unlock tables;
```

特点：

- 如果在主库上进行备份，那么备份期间业务不能做增删改，只能查
- 如果在从库上进行操作，不能同步主库的日志，导致主从延迟
- 这是一个很重的操作



## 表级锁

锁住整张表，发生锁冲突的概率很高，并发度很低，应用在 MyISM，InnoDB等引擎中。

表锁主要有以下三类：表锁，元数据锁，意向锁

### 表锁

分为：表共享读锁（read lock）  和  表独占写锁（write lock）

语法：

```sql
lock tables 表名 read/write

unlock tables 
```

### 元数据锁

（Meta data lock，MDL）  ，无需显示的使用，在访问表的时候会自动加上，MDL的主要作用就是维护表元数据的一致性，在表上有活动事务的时候，不可以对表的元数据进行写入操作。



### 意向锁

为了避免 DML 执行的时候，加的行锁和表锁的冲突，在 InnoDB 中增加了意向锁，让表锁不用检查每行数据是否都加了行锁。

分类：

- 意向共享锁（IS）：与表锁共享锁兼容，与表锁排他锁互斥
- 意向排他锁（IX）：与表锁共享锁及排他锁都互斥。意向锁之间不会互斥



## 行级锁

行级锁每次操作锁住对应的行，锁的粒度小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB引擎中。InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。行级锁主要分为三类：

- 行锁 （record lock）

  锁定单个行记录的锁，防止其他事务对此行记性 update delete 。在 RC RR隔离级别都支持

  ![](https://blog.lichenghao.cn/upload/2022/07/13141518.png)

- 间隙锁（gap lcok）

  锁定索引记录间隙（不包含记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 insert 产生幻读。在 RR 隔离级别下支持。

  ![](https://blog.lichenghao.cn/upload/2022/07/13141703.png)

- 临键锁（next-key lock）

行锁和间隙锁组合，同时锁住数据和数据前面的间隙。在 RR 隔离级别下支持。

![](https://blog.lichenghao.cn/upload/2022/07/13142209.png)



### 行锁

- 共享锁，读锁（S）：允许一个事务读取一行，阻止其他事务获得相同数据集的排它锁
- 排它锁，写锁（X）：允许获取排它锁的事务更新数据，阻止其他事务获取相同的数据集的共享锁和排它锁

也就是说：读读共享，读写互斥，写写互斥。



| SQL                       | 行锁类型 | 备注                                  |
| ------------------------- | -------- | ------------------------------------- |
| insert                    | 排它锁   | 自动加锁                              |
| update                    | 排它锁   | 自动加锁                              |
| delete                    | 排它锁   | 自动加锁                              |
| select......              | **无**   |                                       |
| select lock in share mode | 共享锁   | 需要在后面手动加上 lock in share mode |
| select lock for update    | 排它锁   | 需要手动加上 for update               |



!>行锁是通过对索引上的索引项加锁来实现的，如果不通过索引来查询数据，那么行锁就会升级为表锁！



### 间隙锁 / 临键锁

默认情况InnoDB在 RR事务隔离模式下运行，使用 next-key 锁进行搜索和索引扫描，防止幻读。

- 索引上的等值查询（唯一索引），给不存在的记录加锁的时候，优化为间隙锁。

![](https://blog.lichenghao.cn/upload/2022/07/13151824.png)

如上图，我们更新ID为30的数据，这条数据并不存在，那么间隙锁就会锁住 29~35 这段数据，防止其他事务插入ID 为 30 的数据。

- 索引上的等值查询（普通索引），向右遍历时最后一个值不满足需求时，next-key lock 退化为间隙锁

  因为普通索引是可以重复的，为了防止其他事务在间隙中插入数据，所以需要间隙锁

- 索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止































